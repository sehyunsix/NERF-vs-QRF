% \section{Quantum Perceptron with Quantum Activation Function}
우리는 양자 머신러닝의 큰 진입장벽 중 하나가 비선형성의 구현이라는 것을 이전 장에서 발견했다.
양자 알고리즘의 각 step, 즉 각 게이트를 통과하는 프로세스 하나하나는 모두 각 게이트에 대응되는 행렬을 벡터에 곱해 주는 작업으로 환원된다. 
행렬곱은 본질적으로 선형 연산이므로, 결국 양자 알고리즘으로 완전한 비선형성의 구현이 불가능하다는 결론에 이르게 된다.
인공지능, 그중에서도 MLP(Multi Layer Perceptron)는 행렬 연산의 반복으로 구성되는데, 행렬 연산의 차원을 높이기 위해 각 Layer 사이에 비선형 연산을 추가하는 것이 필수적이라는 사실을 생각하자.
해당 문제의 해결이 선행되기 전까지 MLP를 양자 알고리즘만으로 완전히 구현하는 것은 불가능하다는 것을 어렵지 않게 떠올릴 수 있다.
그렇기에 고전 알고리즘과 양자 알고리즘을 적절히 섞어 사용하는 Hybrid Algorithm이라는 시도가 있다. 하지만 양자 알고리즘만으로 머신 러닝의 과정을 모두 구현하겠다는 시도는 분명 학술적으로 그 가치가 충분하다.

우리는 상기한 문제의 해결 방법을 제시한 논문을 발견하였다.
해당 논문에는 단층 퍼셉트론의 연산 프로세스를 양자 회로로 구현하는 방법이 제시되어 있다.
단층 퍼셉트론은 크게 \(N_{in} \times 1\) 크기의 input vector \(\vec{x}\), 
\(\vec{x}\)의 각 성분과 곱해지게 될 가중치 값이 저장되어 있는 \(N_{in} \times 1\) 크기의 weight vector \(\vec{w}\), 
스칼라 값인 bias \(b\), 그리고 비선형성을 위한 활성화 함수(Activation Function, AF) \(f\)로 구성되어,
\(\vec{x}\)가 input으로 주어지면 \(f(\vec{w}\cdot\vec{x}+b)\)의 값을 내놓는다.
\(z = \vec{w}\cdot\vec{x}+b\)라 하자.
해당 논문은 \(z\)의 계산뿐만 아니라, \(f(z)\)의 계산 또한 양자 알고리즘으로 구현한다.

우리는 해당 논문을 이후 연구의 중심 축으로 결정하였다.
우리는 해당 논문을 이해하고, 수학적 과정을 코드로 구현하여 시각적으로 확인해 보았다.
또한 논문에서는 제대로 논의하고 있지 않은 부분인 MLP의 양자적 구현을 위해 고민하던 중, 우리는 매우 효율적인 Multiperceptron의 양자 알고리즘을 구현하는 데에 성공하였고, 이를 코드로 구현하여 잘 작동함을 확인하였다.

이번 장은 해당 논문에 대한 우리의 심도 깊은 이해와 구현, 그리고 우리가 발전시킨 부분에 대해 서술되어 있다.
4.1장에서는 \(f(\vec{w}\cdot\vec{x}+b)\)를 양자 알고리즘 구현한 과정을 따라가고, 그 과정을 직접 코드로 구현해 본 과정을 공유한다.
이후 4.2장에서는 우리의 독창적이고 효율적인 Multiperceptron의 구현 과정을 설명한다.

\section{Impartion Nonlinearity for Quantum Perceptron}


\subsection{Implementation of \(\vec{w}\cdot\vec{x}+b\)}

첫 번째 단계의 Theorem은 아래와 같다.

\begin{lemma}
    \(\vec{x}, \vec{w}, b\) 가 주어졌을 때, \(\bra{N-1}U_z(\vec{x},\vec{w},b)\ket{0} = \frac{\vec{x}\cdot \vec{w}+b}{N_{in}+1} \equiv z\)
    \(\ket{0} \equiv \ket{0}^{\otimes n}, \ket{N-1} \equiv \ket{1}^{\otimes n}\) 를 만족하는 Unitary transformation \(U_z(\vec{x},\vec{w},b)\) 의 역할을 하는 양자 회로를 만들 수 있다.
    \(\vec{v}_x = (\vec{x},1,A_x,0), \vec{v}_{w,b} = (\vec{w},b,0,A_{w,b}),|\vec{v}_x| = |\vec{v}_{w,b}| = \sqrt{N_{in}+1}\)
    \(\ket{\psi_{x}} = \sum_{i=0}^{N-1}\frac{v_{x,i}}{\sqrt{N_{in}+1}}\ket{i}, \ket{\psi_{w,b}} = \sum_{i=0}^{N-1}\frac{v_{w,b,i}}{\sqrt{N_{in}+1}}\ket{i}\)
\end{lemma}

\begin{theorem}
    \(\vec{x}, \vec{w},b,z = (\vec{w}\cdot\vec{x} + b)/(N_{in}+1) \in [-1,1], N = 2^n\) 에 대하여, 초기에 \(\ket{0}, \ket{0}_q\)로 초기화되어 있는 두 state vector를 (n+d)qubit으로 구성된\(\ket{\psi_z^d}_q = \ket{\psi_z^d}_\perp + \frac{1}{2^{d/2}}\ket{z}_a^{\otimes d}\ket{N-1}_q\)로 변환하는 양자 회로를 구성할 수 있다. 이때 \(\ket{\psi_z^d}_q\)는 \(\ket{N-1} \bra{N-1}_q\ket{\psi_z^d}_\perp = 0, \ket{z} \equiv \ket{0}+z\ket{1}\)를 만족한다. 이때, 우리가 원하는 양자 회로는 \(S_VX_q^{\otimes n}\)으로, X: quantum Not gate, \(V_m = C_{a_m}U_z(\vec{x},\vec{w},b)_qC_{a_m}X_q^{\otimes n}C_q^nH_{a_m}, S_V=V_{d-1}\dots V_1V_0\)을 각각 의미한다.
\end{theorem}

\begin{corollary}
    \(\ket{\psi_z^d}\)에는 \(z^k, (k = 0,1,\dots,d)\) 의 값들이 probability amplitude로 저장되어 있다. Theorem 1의 식 \(\ket{\psi_z^d}_q = \ket{\psi_z^d}_\perp + \frac{1}{2^{d/2}}\ket{z}_a^{\otimes d}\ket{N-1}_q\)에서 \(_q\bra{N-1}_a\bra{2^k-1}\ket{\psi_z^d} = 2^{-d/2}z^k\) 임이 유도된다.
\end{corollary}
이상으로 첫 번째 단계에 대한 구현이 완료되었다.

\subsection{Implementation of \(f(z)\)}

이제 남은 것은 Activation function의 구현이고, 우리가 핵심적으로 관찰해야 했던 과정이다.
양자 알고리즘으로 \(f(z)\)를 구현할 수 있음을 보이고 그 방법론의 타당성을 설명하기 위해서 논문은 크게 두 가지의 단계를 거친다.
우선은 양자 회로로 쉽게 구현할 수 있는 형태의 함수를 결정하고,
어떠한 형태의 함수 f에 대하여, z를 input으로 하면 f(z)의 값을 내놓는 양자 회로를 제시하는 것이다.
그리고 임의의 d차 테일러 전개가 존재하는 함수(analytic 함수)에 대하여, 그 함수의 d차 테일러 전개 \(f_d\)를 일전에 결정한 형태로 작성할 수 있음을 보인다.
이 과정을 통해 양자 회로로 임의의 analytic 함수의 d차 taylor expansion \(f_d\)에 대하여, \(f_d(z)\)의 값을 양자 회로를 통해 계산할 수 있음을 보이는 방식이다.
각 과정은 이하의 theroem과 corollary으로 각각 명시되어 있다.

\begin{theorem}
    \(k = 0,\dots,d-1, \theta_{k} \in [-\frac{\pi}{2},\frac{\pi}{2}]$인 $k, \theta_{k}\)에 대하여, \(f_0(z) = 1, f_z(z) = f_{k-1}(z)\cos\theta_{k-1} - z^k\sin\theta_{k-1}, k = 1,\dots,d\) 로 정의된 \(f_k\)를 생각하자. 그러면 \(_a \langle  0|U_k|z \rangle  _a^{\otimes d} = f_k(z)\)를 만족하는 unitary operator \(U_k = C_{a_0}X_{a_k}\bar{C}_{a_k}R_y(-2\theta_{k-1})_{a_0}U_{k-1}, U_0 = \mathbb{1} \) (이 또한 재귀적으로 정의되어 있다)가 존재한다.
\end{theorem}

\begin{corollary}
    임의의 콤팩트한 집합 \(I\)에서 정의된 analytic function \(f\)에 대하여, 위에서 정의된 방식으로 정의한 \(f_d\)가 \(\theta_k\)를 잘 선택하면 실수 \(C_d = \frac{1}{k!}f^{(k)}(0)\prod_{j=k}^{d-1}(\cos\theta_j)^{-1}\)에 대하여 \(C_df_d\)가 \(f\)의 d차 테일러 전개와 같아진다.
\end{corollary}

우리는 해당 theorem이 실제로 잘 작동하는지 확인하기 위해 f의 구현을 위해 \(\theta_k\)를 계산하고, 이를 양자 회로에 제공하여 z를 입력받으면 \(f(z)\)의 값을 출력하는 부분까지 코드로 구현 완료하였다.


\section{Implementation of Multiperceptron with Superb Efficiency}
Some possible future works. (maybe 0.5\thru3 pages?)